{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/index","pixi-compressed-textures.min.js","src/CompressedImage.js","src/CompressedTextureManager.js","src/extensionChooser.js","src/extensionFixer.js","src/imageParser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","global","compressedTextures","CompressedTextureManager","imageParser","extensionChooser","extensionFixer","detectExtensions","renderer","resolution","extensions","PIXI","WebGLRenderer","data","plugins","compressedTextureManager","getSupportedExtensions","dxt","push","pvrtc","atc","CanvasRenderer","res","ext","slice","pop","loaders","Loader","addPixiMiddleware","loader","use","this","self","window","./CompressedTextureManager.js","./extensionChooser.js","./extensionFixer.js","./imageParser.js",2,"CompressedImage","src","type","width","height","levels","internalFormat","prototype","init","apply","arguments","fourCCToInt32","value","charCodeAt","int32ToFourCC","String","fromCharCode","textureLevelSize","format","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGB_ATC_WEBGL","COMPRESSED_RGB_ETC1_WEBGL","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL","COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","Math","floor","max","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","isCompressedImage","oldComplete","complete","onload","target","dispose","generateWebGLTexture","gl","preserveSource","offset","levelSize","dxtLevel","Uint8Array","buffer","byteOffset","compressedTexImage2D","TEXTURE_2D","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_NEAREST","loadFromArrayBuffer","arrayBuffer","entete","_loadDDS","_loadPVR","header","Int32Array","DDS_HEADER_LENGTH","DDS_HEADER_MAGIC","DDS_MAGIC","DDS_HEADER_PF_FLAGS","DDPF_FOURCC","fourCC","DDS_HEADER_PF_FOURCC","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_ATC","FOURCC_ATCA","FOURCC_ATCI","DDS_HEADER_FLAGS","DDSD_MIPMAPCOUNT","DDS_HEADER_MIPMAPCOUNT","DDS_HEADER_WIDTH","DDS_HEADER_HEIGHT","dataOffset","DDS_HEADER_SIZE","dxtData","PVR_HEADER_LENGTH","PVR_HEADER_MAGIC","PVR_MAGIC","PVR_HEADER_FORMAT","PVR_FORMAT_2BPP_RGB","PVR_FORMAT_2BPP_RGBA","PVR_FORMAT_4BPP_RGB","PVR_FORMAT_4BPP_RGBA","PVR_FORMAT_ETC1","PVR_FORMAT_DXT1","PVR_FORMAT_DXT3","PVR_FORMAT_DXT5","PVR_HEADER_WIDTH","PVR_HEADER_HEIGHT","PVR_HEADER_MIPMAPCOUNT","PVR_HEADER_METADATA","pvrtcData",3,"WebGLManager","core","Object","create","constructor","registerPlugin","getExtension","name","vendorPrefixes","updateTexture","texture","removeSource","source","_glTextures","id","createTexture","on","destroyTexture","bindTexture","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","premultipliedAlpha","updateAllCompressedTextures","resources","key","resource","updateAllTextures","baseTexture","isImage","./CompressedImage",4,"supportedExtensions","next","metadata","choice","url","_defaultUrlChoice","k","lastIndexOf","_baseUrl","substring","j","loadType","_determineLoadType","./imageParser",5,"textureExtensionFixer","_defaultUrl","utils","BaseTextureCache","imageUrl","TextureCache",6,"indexOf","compressedImage","once","Resource","setExtensionXhrType","XHR_RESPONSE_TYPE","BUFFER"],"mappings":"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","file":"pixi-compressed-textures.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (global){\nvar compressedTextures = {\r\n    CompressedTextureManager: require('./CompressedTextureManager.js'),\r\n    imageParser: require('./imageParser.js'),\r\n    extensionChooser: require('./extensionChooser.js'),\r\n    extensionFixer: require('./extensionFixer.js'),\r\n    detectExtensions: function (renderer, resolution) {\r\n        var extensions = [];\r\n        if (renderer instanceof PIXI.WebGLRenderer) {\r\n            var data = renderer.plugins.compressedTextureManager.getSupportedExtensions();\r\n            if (data.dxt) extensions.push('.dds');\r\n            if (data.pvrtc) extensions.push('.pvr');\r\n            if (data.atc) extensions.push('.atc');\r\n        } else if (renderer instanceof PIXI.CanvasRenderer) {\r\n            //nothing special for canvas\r\n        }\r\n        //retina or not\r\n        resolution = resolution || renderer.resolution;\r\n        var res = \"@\"+resolution+\"x\";\r\n        var ext = extensions.slice(0);\r\n        while (ext.length > 0) {\r\n            extensions.push(res + ext.pop());\r\n        }\r\n        extensions.push(res + \".png\");\r\n        extensions.push(res + \".jpg\");\r\n        //atlas support @1x @2x @.5x\r\n        extensions.push(res + \".json\");\r\n        extensions.push(res + \".atlas\");\r\n        return extensions;\r\n    }\r\n};\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(compressedTextures.extensionFixer);\r\nPIXI.loader.use(compressedTextures.extensionFixer());\r\n\r\nmodule.exports = global.PIXI.compressedTextures = compressedTextures;\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tcHJlc3NlZFRleHR1cmVzID0ge1xyXG4gICAgQ29tcHJlc3NlZFRleHR1cmVNYW5hZ2VyOiByZXF1aXJlKCcuL0NvbXByZXNzZWRUZXh0dXJlTWFuYWdlci5qcycpLFxyXG4gICAgaW1hZ2VQYXJzZXI6IHJlcXVpcmUoJy4vaW1hZ2VQYXJzZXIuanMnKSxcclxuICAgIGV4dGVuc2lvbkNob29zZXI6IHJlcXVpcmUoJy4vZXh0ZW5zaW9uQ2hvb3Nlci5qcycpLFxyXG4gICAgZXh0ZW5zaW9uRml4ZXI6IHJlcXVpcmUoJy4vZXh0ZW5zaW9uRml4ZXIuanMnKSxcclxuICAgIGRldGVjdEV4dGVuc2lvbnM6IGZ1bmN0aW9uIChyZW5kZXJlciwgcmVzb2x1dGlvbikge1xyXG4gICAgICAgIHZhciBleHRlbnNpb25zID0gW107XHJcbiAgICAgICAgaWYgKHJlbmRlcmVyIGluc3RhbmNlb2YgUElYSS5XZWJHTFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gcmVuZGVyZXIucGx1Z2lucy5jb21wcmVzc2VkVGV4dHVyZU1hbmFnZXIuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5keHQpIGV4dGVuc2lvbnMucHVzaCgnLmRkcycpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5wdnJ0YykgZXh0ZW5zaW9ucy5wdXNoKCcucHZyJyk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLmF0YykgZXh0ZW5zaW9ucy5wdXNoKCcuYXRjJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIFBJWEkuQ2FudmFzUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgLy9ub3RoaW5nIHNwZWNpYWwgZm9yIGNhbnZhc1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3JldGluYSBvciBub3RcclxuICAgICAgICByZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCByZW5kZXJlci5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciByZXMgPSBcIkBcIityZXNvbHV0aW9uK1wieFwiO1xyXG4gICAgICAgIHZhciBleHQgPSBleHRlbnNpb25zLnNsaWNlKDApO1xyXG4gICAgICAgIHdoaWxlIChleHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2gocmVzICsgZXh0LnBvcCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKHJlcyArIFwiLnBuZ1wiKTtcclxuICAgICAgICBleHRlbnNpb25zLnB1c2gocmVzICsgXCIuanBnXCIpO1xyXG4gICAgICAgIC8vYXRsYXMgc3VwcG9ydCBAMXggQDJ4IEAuNXhcclxuICAgICAgICBleHRlbnNpb25zLnB1c2gocmVzICsgXCIuanNvblwiKTtcclxuICAgICAgICBleHRlbnNpb25zLnB1c2gocmVzICsgXCIuYXRsYXNcIik7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5QSVhJLmxvYWRlcnMuTG9hZGVyLmFkZFBpeGlNaWRkbGV3YXJlKGNvbXByZXNzZWRUZXh0dXJlcy5leHRlbnNpb25GaXhlcik7XHJcblBJWEkubG9hZGVyLnVzZShjb21wcmVzc2VkVGV4dHVyZXMuZXh0ZW5zaW9uRml4ZXIoKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5QSVhJLmNvbXByZXNzZWRUZXh0dXJlcyA9IGNvbXByZXNzZWRUZXh0dXJlcztcclxuIl19","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\nvar compressedTextures = {\r\n    CompressedTextureManager: require('./CompressedTextureManager.js'),\r\n    imageParser: require('./imageParser.js'),\r\n    extensionChooser: require('./extensionChooser.js'),\r\n    extensionFixer: require('./extensionFixer.js'),\r\n    detectExtensions: function (renderer, resolution) {\r\n        var extensions = [];\r\n        if (renderer instanceof PIXI.WebGLRenderer) {\r\n            var data = renderer.plugins.compressedTextureManager.getSupportedExtensions();\r\n            if (data.dxt) extensions.push('.dds');\r\n            if (data.pvrtc) extensions.push('.pvr');\r\n            if (data.atc) extensions.push('.atc');\r\n        } else if (renderer instanceof PIXI.CanvasRenderer) {\r\n            //nothing special for canvas\r\n        }\r\n        //retina or not\r\n        resolution = resolution || renderer.resolution;\r\n        var res = \"@\"+resolution+\"x\";\r\n        var ext = extensions.slice(0);\r\n        while (ext.length > 0) {\r\n            extensions.push(res + ext.pop());\r\n        }\r\n        extensions.push(res + \".png\");\r\n        extensions.push(res + \".jpg\");\r\n        //atlas support @1x @2x @.5x\r\n        extensions.push(res + \".json\");\r\n        extensions.push(res + \".atlas\");\r\n        return extensions;\r\n    }\r\n};\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(compressedTextures.extensionFixer);\r\nPIXI.loader.use(compressedTextures.extensionFixer());\r\n\r\nmodule.exports = global.PIXI.compressedTextures = compressedTextures;\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./CompressedTextureManager.js\":3,\"./extensionChooser.js\":4,\"./extensionFixer.js\":5,\"./imageParser.js\":6}],2:[function(require,module,exports){\nfunction CompressedImage(src, data, type, width, height, levels, internalFormat) {\r\n    CompressedImage.prototype.init.apply(this, arguments);\r\n};\r\n\r\nmodule.exports = CompressedImage;\r\n\r\nCompressedImage.prototype.init = function(src, data, type, width, height, levels, internalFormat) {\r\n    this.src = src;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.data = data;\r\n    this.type = type;\r\n    this.levels = levels;\r\n    this.internalFormat = internalFormat;\r\n    this.isCompressedImage = true;\r\n\r\n    var oldComplete = this.complete;\r\n    this.complete = !!data;\r\n    if (!oldComplete && this.complete && this.onload) {\r\n        this.onload( { target: this } );\r\n    }\r\n    return this;\r\n};\r\n\r\nCompressedImage.prototype.dispose = function() {\r\n    this.data = null;\r\n};\r\n\r\nCompressedImage.prototype.generateWebGLTexture = function (gl, preserveSource) {\r\n    if (this.data == null) {\r\n        throw \"Trying to create a second (or more) webgl texture from the same CompressedImage : \" + this.src;\r\n        return;\r\n    }\r\n\r\n    var width = this.width;\r\n    var height = this.height;\r\n    var levels = this.levels;\r\n    var offset = 0;\r\n    // Loop through each mip level of compressed texture data provided and upload it to the given texture.\r\n    for (var i = 0; i < this.levels; ++i) {\r\n        // Determine how big this level of compressed texture data is in bytes.\r\n        var levelSize = textureLevelSize(this.internalFormat, width, height);\r\n        // Get a view of the bytes for this level of DXT data.\r\n        var dxtLevel = new Uint8Array(this.data.buffer, this.data.byteOffset + offset, levelSize);\r\n        // Upload!\r\n        gl.compressedTexImage2D(gl.TEXTURE_2D, i, this.internalFormat, width, height, 0, dxtLevel);\r\n        // The next mip level will be half the height and width of this one.\r\n        width = width >> 1;\r\n        if (width < 1)\r\n            width = 1;\r\n        height = height >> 1;\r\n        if (height < 1)\r\n            height = 1;\r\n        // Advance the offset into the compressed texture data past the current mip level's data.\r\n        offset += levelSize;\r\n    }\r\n\r\n    // We can't use gl.generateMipmaps with compressed textures, so only use\r\n    // mipmapped filtering if the compressed texture data contained mip levels.\r\n    if (levels > 1) {\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\r\n    }\r\n    else {\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    }\r\n\r\n    // Cleaning the data to save memory. NOTE : BECAUSE OF THIS WE CANNOT CREATE TWO GL TEXTURE FROM THE SAME COMPRESSED IMAGE !\r\n    if (!preserveSource)\r\n        this.data = null;\r\n};\r\n\r\n/**\r\n * Charge une image compressée depuis un array buffer\r\n * @param arrayBuffer : le buffer à partir duquel charger l'image\r\n * @return la CompressedImage chargée\r\n */\r\nCompressedImage.loadFromArrayBuffer = function (arrayBuffer, src) {\r\n    return new CompressedImage(src).loadFromArrayBuffer(arrayBuffer);\r\n};\r\n\r\nCompressedImage.prototype.loadFromArrayBuffer = function(arrayBuffer) {\r\n    var entete = new Uint8Array(arrayBuffer, 0, 3);\r\n\r\n    //todo: implement onload\r\n\r\n    if (entete[0] == \"DDS\".charCodeAt(0) && entete[1] == \"DDS\".charCodeAt(1) && entete[2] == \"DDS\".charCodeAt(2))\r\n        return this._loadDDS(arrayBuffer);\r\n    else if (entete[0] == \"PVR\".charCodeAt(0) && entete[1] == \"PVR\".charCodeAt(1) && entete[2] == \"PVR\".charCodeAt(2))\r\n        return this._loadPVR(arrayBuffer);\r\n    else\r\n        throw \"Compressed texture format is not recognized: \" + src;\r\n    return this;\r\n}\r\n\r\n/**\r\n * Charge une image compressГ©e au format DDS depuis un array buffer\r\n * @param arrayBuffer : le buffer Г  partir duquel charger l'image\r\n * @return la CompressedImage chargГ©e\r\n */\r\nCompressedImage.prototype._loadDDS = function(arrayBuffer) {\r\n    // Get a view of the arrayBuffer that represents the DDS header.\r\n    var header = new Int32Array(arrayBuffer, 0, DDS_HEADER_LENGTH);\r\n\r\n    // Do some sanity checks to make sure this is a valid DDS file.\r\n    if (header[DDS_HEADER_MAGIC] != DDS_MAGIC)\r\n        throw \"Invalid magic number in DDS header\";\r\n\r\n    if (!header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC)\r\n        throw \"Unsupported format, must contain a FourCC code\";\r\n\r\n    // Determine what type of compressed data the file contains.\r\n    var fourCC = header[DDS_HEADER_PF_FOURCC];\r\n    var internalFormat;\r\n    switch (fourCC) {\r\n        case FOURCC_DXT1:\r\n            internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n            break;\r\n        case FOURCC_DXT3:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n            break;\r\n        case FOURCC_DXT5:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n            break;\r\n        case FOURCC_ATC:\r\n            internalFormat = COMPRESSED_RGB_ATC_WEBGL;\r\n            break;\r\n        case FOURCC_ATCA:\r\n            internalFormat = COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL;\r\n            break;\r\n        case FOURCC_ATCI:\r\n            internalFormat = COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;\r\n            break;\r\n        default:\r\n            throw \"Unsupported FourCC code: \" + int32ToFourCC(fourCC);\r\n    }\r\n\r\n    // Determine how many mipmap levels the file contains.\r\n    var levels = 1;\r\n    if (header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {\r\n        levels = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);\r\n    }\r\n\r\n    // Gather other basic metrics and a view of the raw the DXT data.\r\n    var width = header[DDS_HEADER_WIDTH];\r\n    var height = header[DDS_HEADER_HEIGHT];\r\n    var dataOffset = header[DDS_HEADER_SIZE] + 4;\r\n    var dxtData = new Uint8Array(arrayBuffer, dataOffset);\r\n\r\n    return this.init(this.src, dxtData, 'DDS', width, height, levels, internalFormat);\r\n};\r\n\r\n/**\r\n * Charge une image compressГ©e au format PVR depuis un array buffer\r\n * @param arrayBuffer : le buffer Г  partir duquel charger l'image\r\n * @return la CompressedImage chargГ©e\r\n */\r\nCompressedImage.prototype._loadPVR = function(arrayBuffer) {\r\n    // Get a view of the arrayBuffer that represents the DDS header.\r\n    var header = new Int32Array(arrayBuffer, 0, PVR_HEADER_LENGTH);\r\n\r\n    // Do some sanity checks to make sure this is a valid DDS file.\r\n    if (header[PVR_HEADER_MAGIC] != PVR_MAGIC)\r\n        throw \"Invalid magic number in PVR header\";\r\n\r\n    // Determine what type of compressed data the file contains.\r\n    var format = header[PVR_HEADER_FORMAT];\r\n    var internalFormat;\r\n    switch (format) {\r\n        case PVR_FORMAT_2BPP_RGB:\r\n            internalFormat = COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_2BPP_RGBA:\r\n            internalFormat = COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_4BPP_RGB:\r\n            internalFormat = COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_4BPP_RGBA:\r\n            internalFormat = COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_ETC1:\r\n            internalFormat = COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case PVR_FORMAT_DXT1:\r\n            internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n            break;\r\n        case PVR_FORMAT_DXT3:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n            break;\r\n        case PVR_FORMAT_DXT5:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n            break;\r\n        default:\r\n            throw \"Unsupported PVR format: \" + format;\r\n    }\r\n\r\n    // Gather other basic metrics and a view of the raw the DXT data.\r\n    var width = header[PVR_HEADER_WIDTH];\r\n    var height = header[PVR_HEADER_HEIGHT];\r\n    var levels = header[PVR_HEADER_MIPMAPCOUNT];\r\n    var dataOffset = header[PVR_HEADER_METADATA] + 52;\r\n    var pvrtcData = new Uint8Array(arrayBuffer, dataOffset);\r\n\r\n    return this.init(this.src, pvrtcData, 'PVR', width, height, levels, internalFormat);\r\n};\r\n\r\n\r\n//============================//\r\n// DXT constants and utilites //\r\n//============================//\r\n\r\n// Utility functions\r\n// Builds a numeric code for a given fourCC string\r\nfunction fourCCToInt32(value) {\r\n    return value.charCodeAt(0) +\r\n        (value.charCodeAt(1) << 8) +\r\n        (value.charCodeAt(2) << 16) +\r\n        (value.charCodeAt(3) << 24);\r\n}\r\n\r\n// Turns a fourCC numeric code into a string\r\nfunction int32ToFourCC(value) {\r\n    return String.fromCharCode(\r\n        value & 0xff,\r\n        (value >> 8) & 0xff,\r\n        (value >> 16) & 0xff,\r\n        (value >> 24) & 0xff\r\n    );\r\n}\r\n\r\n// Calcualates the size of a compressed texture level in bytes\r\nfunction textureLevelSize(format, width, height) {\r\n    switch (format) {\r\n        case COMPRESSED_RGB_S3TC_DXT1_EXT:\r\n        case COMPRESSED_RGB_ATC_WEBGL:\r\n        case COMPRESSED_RGB_ETC1_WEBGL:\r\n            return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\r\n\r\n        case COMPRESSED_RGBA_S3TC_DXT3_EXT:\r\n        case COMPRESSED_RGBA_S3TC_DXT5_EXT:\r\n        case COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:\r\n        case COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:\r\n            return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\r\n\r\n        case COMPRESSED_RGB_PVRTC_4BPPV1_IMG:\r\n        case COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:\r\n            return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);\r\n\r\n        case COMPRESSED_RGB_PVRTC_2BPPV1_IMG:\r\n        case COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:\r\n            return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);\r\n\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\n// DXT formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\r\nvar COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\r\nvar COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\r\nvar COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\r\nvar COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\r\n\r\n// ATC formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_atc/\r\nvar COMPRESSED_RGB_ATC_WEBGL = 0x8C92;\r\nvar COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;\r\nvar COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\r\n\r\n// DXT values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nvar DDS_MAGIC = 0x20534444;\r\nvar DDSD_MIPMAPCOUNT = 0x20000;\r\nvar DDPF_FOURCC = 0x4;\r\n\r\nvar DDS_HEADER_LENGTH = 31; // The header length in 32 bit ints.\r\n\r\n// Offsets into the header array.\r\nvar DDS_HEADER_MAGIC = 0;\r\n\r\nvar DDS_HEADER_SIZE = 1;\r\nvar DDS_HEADER_FLAGS = 2;\r\nvar DDS_HEADER_HEIGHT = 3;\r\nvar DDS_HEADER_WIDTH = 4;\r\n\r\nvar DDS_HEADER_MIPMAPCOUNT = 7;\r\n\r\nvar DDS_HEADER_PF_FLAGS = 20;\r\nvar DDS_HEADER_PF_FOURCC = 21;\r\n\r\n// FourCC format identifiers.\r\nvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\r\nvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\r\nvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\r\n\r\nvar FOURCC_ATC = fourCCToInt32(\"ATC \");\r\nvar FOURCC_ATCA = fourCCToInt32(\"ATCA\");\r\nvar FOURCC_ATCI = fourCCToInt32(\"ATCI\");\r\n\r\n//===============//\r\n// PVR constants //\r\n//===============//\r\n\r\n// PVR formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\r\nvar COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;\r\nvar COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;\r\nvar COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\r\nvar COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\r\n\r\n// ETC1 format, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/\r\nvar COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;\r\n\r\nvar PVR_FORMAT_2BPP_RGB = 0;\r\nvar PVR_FORMAT_2BPP_RGBA = 1;\r\nvar PVR_FORMAT_4BPP_RGB = 2;\r\nvar PVR_FORMAT_4BPP_RGBA = 3;\r\nvar PVR_FORMAT_ETC1 = 6;\r\nvar PVR_FORMAT_DXT1 = 7;\r\nvar PVR_FORMAT_DXT3 = 9;\r\nvar PVR_FORMAT_DXT5 = 5;\r\n\r\nvar PVR_HEADER_LENGTH = 13; // The header length in 32 bit ints.\r\nvar PVR_MAGIC = 0x03525650; //0x50565203;\r\n\r\n// Offsets into the header array.\r\nvar PVR_HEADER_MAGIC = 0;\r\nvar PVR_HEADER_FORMAT = 2;\r\nvar PVR_HEADER_HEIGHT = 6;\r\nvar PVR_HEADER_WIDTH = 7;\r\nvar PVR_HEADER_MIPMAPCOUNT = 11;\r\nvar PVR_HEADER_METADATA = 12;\r\n\n},{}],3:[function(require,module,exports){\n/**\r\n * Created by Liza on 12.12.2015.\r\n */\r\n\r\nvar core = PIXI,\r\n    CompressedImage = require('./CompressedImage'),\r\n    WebGLManager = core.WebGLManager;\r\n/**\r\n * @class\r\n * @memberof PIXI.compressedTextures\r\n * @extends PIXI.WebGlManager\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\r\n */\r\nfunction CompressedTextureManager(renderer) {\r\n    WebGLManager.call(this, renderer);\r\n}\r\n\r\nCompressedTextureManager.prototype = Object.create(WebGLManager.prototype);\r\nCompressedTextureManager.prototype.constructor = CompressedTextureManager;\r\nmodule.exports = CompressedTextureManager;\r\n\r\ncore.WebGLRenderer.registerPlugin('compressedTextureManager', CompressedTextureManager);\r\n\r\nCompressedTextureManager.prototype.getSupportedExtensions = function () {\r\n    var gl = this.renderer.gl;\r\n    function getExtension(gl, name) {\r\n        var vendorPrefixes = [\"\", \"WEBKIT_\", \"MOZ_\"];\r\n        var ext = null;\r\n        for (var i in vendorPrefixes) {\r\n            ext = gl.getExtension(vendorPrefixes[i] + name);\r\n            if (ext) {\r\n                break;\r\n            }\r\n        }\r\n        return ext;\r\n    }\r\n\r\n    return {\r\n        dxt: getExtension(gl, \"WEBGL_compressed_texture_s3tc\"),\r\n        pvrtc: getExtension(gl, \"WEBGL_compressed_texture_pvrtc\"),\r\n        atc: getExtension(gl, \"WEBGL_compressed_texture_atc\")\r\n    }\r\n};\r\n\r\nCompressedTextureManager.prototype.updateTexture = function (texture, removeSource) {\r\n    var source = texture.source;\r\n    if (!(source instanceof CompressedImage)) {\r\n        throw \"Not a compressed image\";\r\n    }\r\n    var renderer = this.renderer;\r\n    var gl = this.renderer.gl;\r\n    if (!source.complete) {\r\n        throw \"Trying to update compressed texture that isnt loaded yet.\";\r\n    }\r\n    if (!texture._glTextures[gl.id]) {\r\n        texture._glTextures[gl.id] = gl.createTexture();\r\n        texture.on('dispose', renderer.destroyTexture, renderer);\r\n    }\r\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);\r\n    source.generateWebGLTexture(gl, !removeSource);\r\n};\r\n\r\nCompressedTextureManager.prototype.updateAllCompressedTextures = function (resources, removeSource) {\r\n    for (var key in resources) {\r\n        var resource = resources[key];\r\n        if (resource.isCompressedImage) {\r\n            this.updateTexture(resource.texture, removeSource);\r\n        }\r\n    }\r\n};\r\n\r\nCompressedTextureManager.prototype.updateAllTextures = function (resources, removeSource) {\r\n    for (var key in resources) {\r\n        var resource = resources[key];\r\n        if (resource.isCompressedImage) {\r\n            this.updateTexture(resource.texture.baseTexture, removeSource);\r\n        } else if (resource.isImage) {\r\n            this.renderer.updateTexture(resource.texture.baseTexture);\r\n        }\r\n    }\r\n};\n},{\"./CompressedImage\":2}],4:[function(require,module,exports){\nfunction extensionChooser(supportedExtensions) {\n    supportedExtensions = supportedExtensions || [];\n\n    var imageParser = require('./imageParser')();\n\n    return function (resource, next) {\n        var ext = resource.metadata.choice;\n        if (!ext) {\n            return next();\n        }\n        //let us choose extension!\n        var url = resource.url;\n        if (!resource._defaultUrlChoice) {\n            resource._defaultUrlChoice = url;\n            var k = url.lastIndexOf(\".\");\n            if (k >= 0) {\n                resource._baseUrl = url.substring(0, k);\n            } else {\n                return next();\n            }\n        }\n        for (var i = ext.length - 1; i >= 0; i--) {\n            url = resource._baseUrl + ext[i];\n            var isSupported = false;\n            for (var j = 0; j < supportedExtensions.length; j++) {\n                if (ext[i] === supportedExtensions[j]) {\n                    resource.url = url;\n                    resource.loadType = resource._determineLoadType();\n                    return imageParser(resource, next);\n                }\n            }\n        }\n        return imageParser(resource, next);\n    };\n}\n\nmodule.exports = extensionChooser;\n\n},{\"./imageParser\":6}],5:[function(require,module,exports){\nvar core = PIXI,\r\n    utils = core.utils,\r\n    extensionFixer = require('./CompressedImage');\r\n\r\nfunction textureExtensionFixer(supportedExtensions) {\r\n    return function (resource, next) {\r\n        if (resource.texture && resource._defaultUrlChoice && resource._defaultUrl != resource.url) {\r\n            var texture = resource.texture;\r\n            var baseTexture = texture.baseTexture;\r\n            delete utils.BaseTextureCache[baseTexture.imageUrl];\r\n            delete utils.TextureCache[baseTexture.imageUrl];\r\n            baseTexture.imageUrl = resource._defaultUrlChoice;\r\n            core.utils.BaseTextureCache[baseTexture.imageUrl] = baseTexture;\r\n            core.utils.TextureCache[baseTexture.imageUrl] = texture;\r\n        }\r\n        next();\r\n    }\r\n}\r\n\r\nmodule.exports = textureExtensionFixer;\r\n\n},{\"./CompressedImage\":2}],6:[function(require,module,exports){\nvar core = PIXI,\n    utils = core.utils,\n    CompressedImage = require('./CompressedImage'),\n    Resource = core.loaders.Resource;\n\nResource.setExtensionXhrType('dds', Resource.XHR_RESPONSE_TYPE.BUFFER);\nResource.setExtensionXhrType('pvr', Resource.XHR_RESPONSE_TYPE.BUFFER);\n\nfunction imageParser() {\n    return function (resource, next) {\n        if (resource.url.indexOf('.dds') != -1 || resource.url.indexOf('.pvr') != -1) {\n            var compressedImage = resource.compressedImage || new CompressedImage(resource.url);\n            if (resource.data) {\n                throw \"compressedImageParser middleware must be specified in loader.before() and must have zero resource.data\";\n            }\n            resource.isCompressedImage = true;\n            resource.data = compressedImage;\n            resource.once('complete', function() {\n                resource.isImage = true;\n                compressedImage.loadFromArrayBuffer(resource.data);\n                resource.data = compressedImage;\n            });\n        }\n        next();\n    }\n}\n\nmodule.exports = imageParser;\n\n},{\"./CompressedImage\":2}]},{},[1])\n\n","function CompressedImage(src, data, type, width, height, levels, internalFormat) {\r\n    CompressedImage.prototype.init.apply(this, arguments);\r\n};\r\n\r\nmodule.exports = CompressedImage;\r\n\r\nCompressedImage.prototype.init = function(src, data, type, width, height, levels, internalFormat) {\r\n    this.src = src;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.data = data;\r\n    this.type = type;\r\n    this.levels = levels;\r\n    this.internalFormat = internalFormat;\r\n    this.isCompressedImage = true;\r\n\r\n    var oldComplete = this.complete;\r\n    this.complete = !!data;\r\n    if (!oldComplete && this.complete && this.onload) {\r\n        this.onload( { target: this } );\r\n    }\r\n    return this;\r\n};\r\n\r\nCompressedImage.prototype.dispose = function() {\r\n    this.data = null;\r\n};\r\n\r\nCompressedImage.prototype.generateWebGLTexture = function (gl, preserveSource) {\r\n    if (this.data == null) {\r\n        throw \"Trying to create a second (or more) webgl texture from the same CompressedImage : \" + this.src;\r\n        return;\r\n    }\r\n\r\n    var width = this.width;\r\n    var height = this.height;\r\n    var levels = this.levels;\r\n    var offset = 0;\r\n    // Loop through each mip level of compressed texture data provided and upload it to the given texture.\r\n    for (var i = 0; i < this.levels; ++i) {\r\n        // Determine how big this level of compressed texture data is in bytes.\r\n        var levelSize = textureLevelSize(this.internalFormat, width, height);\r\n        // Get a view of the bytes for this level of DXT data.\r\n        var dxtLevel = new Uint8Array(this.data.buffer, this.data.byteOffset + offset, levelSize);\r\n        // Upload!\r\n        gl.compressedTexImage2D(gl.TEXTURE_2D, i, this.internalFormat, width, height, 0, dxtLevel);\r\n        // The next mip level will be half the height and width of this one.\r\n        width = width >> 1;\r\n        if (width < 1)\r\n            width = 1;\r\n        height = height >> 1;\r\n        if (height < 1)\r\n            height = 1;\r\n        // Advance the offset into the compressed texture data past the current mip level's data.\r\n        offset += levelSize;\r\n    }\r\n\r\n    // We can't use gl.generateMipmaps with compressed textures, so only use\r\n    // mipmapped filtering if the compressed texture data contained mip levels.\r\n    if (levels > 1) {\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\r\n    }\r\n    else {\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    }\r\n\r\n    // Cleaning the data to save memory. NOTE : BECAUSE OF THIS WE CANNOT CREATE TWO GL TEXTURE FROM THE SAME COMPRESSED IMAGE !\r\n    if (!preserveSource)\r\n        this.data = null;\r\n};\r\n\r\n/**\r\n * Charge une image compressée depuis un array buffer\r\n * @param arrayBuffer : le buffer à partir duquel charger l'image\r\n * @return la CompressedImage chargée\r\n */\r\nCompressedImage.loadFromArrayBuffer = function (arrayBuffer, src) {\r\n    return new CompressedImage(src).loadFromArrayBuffer(arrayBuffer);\r\n};\r\n\r\nCompressedImage.prototype.loadFromArrayBuffer = function(arrayBuffer) {\r\n    var entete = new Uint8Array(arrayBuffer, 0, 3);\r\n\r\n    //todo: implement onload\r\n\r\n    if (entete[0] == \"DDS\".charCodeAt(0) && entete[1] == \"DDS\".charCodeAt(1) && entete[2] == \"DDS\".charCodeAt(2))\r\n        return this._loadDDS(arrayBuffer);\r\n    else if (entete[0] == \"PVR\".charCodeAt(0) && entete[1] == \"PVR\".charCodeAt(1) && entete[2] == \"PVR\".charCodeAt(2))\r\n        return this._loadPVR(arrayBuffer);\r\n    else\r\n        throw \"Compressed texture format is not recognized: \" + src;\r\n    return this;\r\n}\r\n\r\n/**\r\n * Charge une image compressГ©e au format DDS depuis un array buffer\r\n * @param arrayBuffer : le buffer Г  partir duquel charger l'image\r\n * @return la CompressedImage chargГ©e\r\n */\r\nCompressedImage.prototype._loadDDS = function(arrayBuffer) {\r\n    // Get a view of the arrayBuffer that represents the DDS header.\r\n    var header = new Int32Array(arrayBuffer, 0, DDS_HEADER_LENGTH);\r\n\r\n    // Do some sanity checks to make sure this is a valid DDS file.\r\n    if (header[DDS_HEADER_MAGIC] != DDS_MAGIC)\r\n        throw \"Invalid magic number in DDS header\";\r\n\r\n    if (!header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC)\r\n        throw \"Unsupported format, must contain a FourCC code\";\r\n\r\n    // Determine what type of compressed data the file contains.\r\n    var fourCC = header[DDS_HEADER_PF_FOURCC];\r\n    var internalFormat;\r\n    switch (fourCC) {\r\n        case FOURCC_DXT1:\r\n            internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n            break;\r\n        case FOURCC_DXT3:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n            break;\r\n        case FOURCC_DXT5:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n            break;\r\n        case FOURCC_ATC:\r\n            internalFormat = COMPRESSED_RGB_ATC_WEBGL;\r\n            break;\r\n        case FOURCC_ATCA:\r\n            internalFormat = COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL;\r\n            break;\r\n        case FOURCC_ATCI:\r\n            internalFormat = COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;\r\n            break;\r\n        default:\r\n            throw \"Unsupported FourCC code: \" + int32ToFourCC(fourCC);\r\n    }\r\n\r\n    // Determine how many mipmap levels the file contains.\r\n    var levels = 1;\r\n    if (header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {\r\n        levels = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);\r\n    }\r\n\r\n    // Gather other basic metrics and a view of the raw the DXT data.\r\n    var width = header[DDS_HEADER_WIDTH];\r\n    var height = header[DDS_HEADER_HEIGHT];\r\n    var dataOffset = header[DDS_HEADER_SIZE] + 4;\r\n    var dxtData = new Uint8Array(arrayBuffer, dataOffset);\r\n\r\n    return this.init(this.src, dxtData, 'DDS', width, height, levels, internalFormat);\r\n};\r\n\r\n/**\r\n * Charge une image compressГ©e au format PVR depuis un array buffer\r\n * @param arrayBuffer : le buffer Г  partir duquel charger l'image\r\n * @return la CompressedImage chargГ©e\r\n */\r\nCompressedImage.prototype._loadPVR = function(arrayBuffer) {\r\n    // Get a view of the arrayBuffer that represents the DDS header.\r\n    var header = new Int32Array(arrayBuffer, 0, PVR_HEADER_LENGTH);\r\n\r\n    // Do some sanity checks to make sure this is a valid DDS file.\r\n    if (header[PVR_HEADER_MAGIC] != PVR_MAGIC)\r\n        throw \"Invalid magic number in PVR header\";\r\n\r\n    // Determine what type of compressed data the file contains.\r\n    var format = header[PVR_HEADER_FORMAT];\r\n    var internalFormat;\r\n    switch (format) {\r\n        case PVR_FORMAT_2BPP_RGB:\r\n            internalFormat = COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_2BPP_RGBA:\r\n            internalFormat = COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_4BPP_RGB:\r\n            internalFormat = COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_4BPP_RGBA:\r\n            internalFormat = COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_ETC1:\r\n            internalFormat = COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case PVR_FORMAT_DXT1:\r\n            internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n            break;\r\n        case PVR_FORMAT_DXT3:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n            break;\r\n        case PVR_FORMAT_DXT5:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n            break;\r\n        default:\r\n            throw \"Unsupported PVR format: \" + format;\r\n    }\r\n\r\n    // Gather other basic metrics and a view of the raw the DXT data.\r\n    var width = header[PVR_HEADER_WIDTH];\r\n    var height = header[PVR_HEADER_HEIGHT];\r\n    var levels = header[PVR_HEADER_MIPMAPCOUNT];\r\n    var dataOffset = header[PVR_HEADER_METADATA] + 52;\r\n    var pvrtcData = new Uint8Array(arrayBuffer, dataOffset);\r\n\r\n    return this.init(this.src, pvrtcData, 'PVR', width, height, levels, internalFormat);\r\n};\r\n\r\n\r\n//============================//\r\n// DXT constants and utilites //\r\n//============================//\r\n\r\n// Utility functions\r\n// Builds a numeric code for a given fourCC string\r\nfunction fourCCToInt32(value) {\r\n    return value.charCodeAt(0) +\r\n        (value.charCodeAt(1) << 8) +\r\n        (value.charCodeAt(2) << 16) +\r\n        (value.charCodeAt(3) << 24);\r\n}\r\n\r\n// Turns a fourCC numeric code into a string\r\nfunction int32ToFourCC(value) {\r\n    return String.fromCharCode(\r\n        value & 0xff,\r\n        (value >> 8) & 0xff,\r\n        (value >> 16) & 0xff,\r\n        (value >> 24) & 0xff\r\n    );\r\n}\r\n\r\n// Calcualates the size of a compressed texture level in bytes\r\nfunction textureLevelSize(format, width, height) {\r\n    switch (format) {\r\n        case COMPRESSED_RGB_S3TC_DXT1_EXT:\r\n        case COMPRESSED_RGB_ATC_WEBGL:\r\n        case COMPRESSED_RGB_ETC1_WEBGL:\r\n            return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\r\n\r\n        case COMPRESSED_RGBA_S3TC_DXT3_EXT:\r\n        case COMPRESSED_RGBA_S3TC_DXT5_EXT:\r\n        case COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:\r\n        case COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:\r\n            return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\r\n\r\n        case COMPRESSED_RGB_PVRTC_4BPPV1_IMG:\r\n        case COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:\r\n            return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);\r\n\r\n        case COMPRESSED_RGB_PVRTC_2BPPV1_IMG:\r\n        case COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:\r\n            return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);\r\n\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\n// DXT formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\r\nvar COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\r\nvar COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\r\nvar COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\r\nvar COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\r\n\r\n// ATC formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_atc/\r\nvar COMPRESSED_RGB_ATC_WEBGL = 0x8C92;\r\nvar COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;\r\nvar COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\r\n\r\n// DXT values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nvar DDS_MAGIC = 0x20534444;\r\nvar DDSD_MIPMAPCOUNT = 0x20000;\r\nvar DDPF_FOURCC = 0x4;\r\n\r\nvar DDS_HEADER_LENGTH = 31; // The header length in 32 bit ints.\r\n\r\n// Offsets into the header array.\r\nvar DDS_HEADER_MAGIC = 0;\r\n\r\nvar DDS_HEADER_SIZE = 1;\r\nvar DDS_HEADER_FLAGS = 2;\r\nvar DDS_HEADER_HEIGHT = 3;\r\nvar DDS_HEADER_WIDTH = 4;\r\n\r\nvar DDS_HEADER_MIPMAPCOUNT = 7;\r\n\r\nvar DDS_HEADER_PF_FLAGS = 20;\r\nvar DDS_HEADER_PF_FOURCC = 21;\r\n\r\n// FourCC format identifiers.\r\nvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\r\nvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\r\nvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\r\n\r\nvar FOURCC_ATC = fourCCToInt32(\"ATC \");\r\nvar FOURCC_ATCA = fourCCToInt32(\"ATCA\");\r\nvar FOURCC_ATCI = fourCCToInt32(\"ATCI\");\r\n\r\n//===============//\r\n// PVR constants //\r\n//===============//\r\n\r\n// PVR formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\r\nvar COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;\r\nvar COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;\r\nvar COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\r\nvar COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\r\n\r\n// ETC1 format, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/\r\nvar COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;\r\n\r\nvar PVR_FORMAT_2BPP_RGB = 0;\r\nvar PVR_FORMAT_2BPP_RGBA = 1;\r\nvar PVR_FORMAT_4BPP_RGB = 2;\r\nvar PVR_FORMAT_4BPP_RGBA = 3;\r\nvar PVR_FORMAT_ETC1 = 6;\r\nvar PVR_FORMAT_DXT1 = 7;\r\nvar PVR_FORMAT_DXT3 = 9;\r\nvar PVR_FORMAT_DXT5 = 5;\r\n\r\nvar PVR_HEADER_LENGTH = 13; // The header length in 32 bit ints.\r\nvar PVR_MAGIC = 0x03525650; //0x50565203;\r\n\r\n// Offsets into the header array.\r\nvar PVR_HEADER_MAGIC = 0;\r\nvar PVR_HEADER_FORMAT = 2;\r\nvar PVR_HEADER_HEIGHT = 6;\r\nvar PVR_HEADER_WIDTH = 7;\r\nvar PVR_HEADER_MIPMAPCOUNT = 11;\r\nvar PVR_HEADER_METADATA = 12;\r\n","/**\r\n * Created by Liza on 12.12.2015.\r\n */\r\n\r\nvar core = PIXI,\r\n    CompressedImage = require('./CompressedImage'),\r\n    WebGLManager = core.WebGLManager;\r\n/**\r\n * @class\r\n * @memberof PIXI.compressedTextures\r\n * @extends PIXI.WebGlManager\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\r\n */\r\nfunction CompressedTextureManager(renderer) {\r\n    WebGLManager.call(this, renderer);\r\n}\r\n\r\nCompressedTextureManager.prototype = Object.create(WebGLManager.prototype);\r\nCompressedTextureManager.prototype.constructor = CompressedTextureManager;\r\nmodule.exports = CompressedTextureManager;\r\n\r\ncore.WebGLRenderer.registerPlugin('compressedTextureManager', CompressedTextureManager);\r\n\r\nCompressedTextureManager.prototype.getSupportedExtensions = function () {\r\n    var gl = this.renderer.gl;\r\n    function getExtension(gl, name) {\r\n        var vendorPrefixes = [\"\", \"WEBKIT_\", \"MOZ_\"];\r\n        var ext = null;\r\n        for (var i in vendorPrefixes) {\r\n            ext = gl.getExtension(vendorPrefixes[i] + name);\r\n            if (ext) {\r\n                break;\r\n            }\r\n        }\r\n        return ext;\r\n    }\r\n\r\n    return {\r\n        dxt: getExtension(gl, \"WEBGL_compressed_texture_s3tc\"),\r\n        pvrtc: getExtension(gl, \"WEBGL_compressed_texture_pvrtc\"),\r\n        atc: getExtension(gl, \"WEBGL_compressed_texture_atc\")\r\n    }\r\n};\r\n\r\nCompressedTextureManager.prototype.updateTexture = function (texture, removeSource) {\r\n    var source = texture.source;\r\n    if (!(source instanceof CompressedImage)) {\r\n        throw \"Not a compressed image\";\r\n    }\r\n    var renderer = this.renderer;\r\n    var gl = this.renderer.gl;\r\n    if (!source.complete) {\r\n        throw \"Trying to update compressed texture that isnt loaded yet.\";\r\n    }\r\n    if (!texture._glTextures[gl.id]) {\r\n        texture._glTextures[gl.id] = gl.createTexture();\r\n        texture.on('dispose', renderer.destroyTexture, renderer);\r\n    }\r\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);\r\n    source.generateWebGLTexture(gl, !removeSource);\r\n};\r\n\r\nCompressedTextureManager.prototype.updateAllCompressedTextures = function (resources, removeSource) {\r\n    for (var key in resources) {\r\n        var resource = resources[key];\r\n        if (resource.isCompressedImage) {\r\n            this.updateTexture(resource.texture, removeSource);\r\n        }\r\n    }\r\n};\r\n\r\nCompressedTextureManager.prototype.updateAllTextures = function (resources, removeSource) {\r\n    for (var key in resources) {\r\n        var resource = resources[key];\r\n        if (resource.isCompressedImage) {\r\n            this.updateTexture(resource.texture.baseTexture, removeSource);\r\n        } else if (resource.isImage) {\r\n            this.renderer.updateTexture(resource.texture.baseTexture);\r\n        }\r\n    }\r\n};","function extensionChooser(supportedExtensions) {\n    supportedExtensions = supportedExtensions || [];\n\n    var imageParser = require('./imageParser')();\n\n    return function (resource, next) {\n        var ext = resource.metadata.choice;\n        if (!ext) {\n            return next();\n        }\n        //let us choose extension!\n        var url = resource.url;\n        if (!resource._defaultUrlChoice) {\n            resource._defaultUrlChoice = url;\n            var k = url.lastIndexOf(\".\");\n            if (k >= 0) {\n                resource._baseUrl = url.substring(0, k);\n            } else {\n                return next();\n            }\n        }\n        for (var i = ext.length - 1; i >= 0; i--) {\n            url = resource._baseUrl + ext[i];\n            var isSupported = false;\n            for (var j = 0; j < supportedExtensions.length; j++) {\n                if (ext[i] === supportedExtensions[j]) {\n                    resource.url = url;\n                    resource.loadType = resource._determineLoadType();\n                    return imageParser(resource, next);\n                }\n            }\n        }\n        return imageParser(resource, next);\n    };\n}\n\nmodule.exports = extensionChooser;\n","var core = PIXI,\r\n    utils = core.utils,\r\n    extensionFixer = require('./CompressedImage');\r\n\r\nfunction textureExtensionFixer(supportedExtensions) {\r\n    return function (resource, next) {\r\n        if (resource.texture && resource._defaultUrlChoice && resource._defaultUrl != resource.url) {\r\n            var texture = resource.texture;\r\n            var baseTexture = texture.baseTexture;\r\n            delete utils.BaseTextureCache[baseTexture.imageUrl];\r\n            delete utils.TextureCache[baseTexture.imageUrl];\r\n            baseTexture.imageUrl = resource._defaultUrlChoice;\r\n            core.utils.BaseTextureCache[baseTexture.imageUrl] = baseTexture;\r\n            core.utils.TextureCache[baseTexture.imageUrl] = texture;\r\n        }\r\n        next();\r\n    }\r\n}\r\n\r\nmodule.exports = textureExtensionFixer;\r\n","var core = PIXI,\n    utils = core.utils,\n    CompressedImage = require('./CompressedImage'),\n    Resource = core.loaders.Resource;\n\nResource.setExtensionXhrType('dds', Resource.XHR_RESPONSE_TYPE.BUFFER);\nResource.setExtensionXhrType('pvr', Resource.XHR_RESPONSE_TYPE.BUFFER);\n\nfunction imageParser() {\n    return function (resource, next) {\n        if (resource.url.indexOf('.dds') != -1 || resource.url.indexOf('.pvr') != -1) {\n            var compressedImage = resource.compressedImage || new CompressedImage(resource.url);\n            if (resource.data) {\n                throw \"compressedImageParser middleware must be specified in loader.before() and must have zero resource.data\";\n            }\n            resource.isCompressedImage = true;\n            resource.data = compressedImage;\n            resource.once('complete', function() {\n                resource.isImage = true;\n                compressedImage.loadFromArrayBuffer(resource.data);\n                resource.data = compressedImage;\n            });\n        }\n        next();\n    }\n}\n\nmodule.exports = imageParser;\n"],"sourceRoot":"./"}