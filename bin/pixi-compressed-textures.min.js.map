{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/index","pixi-compressed-textures.min.js","src/CompressedImage.js","src/CompressedTextureManager.js","src/compressedImageParser.js","src/extensionChooser.js","src/extensionFixer.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","global","compressedTextures","CompressedTextureManager","compressedImageParser","extensionChooser","extensionFixer","detectExtensions","renderer","PIXI","WebGLRenderer","data","plugins","getSupportedExtensions","dxt","extensions","push","pvrtc","atc","CanvasRenderer","resolution","ext","slice","pop","loaders","Loader","addPixiMiddleware","loader","use","this","self","window","./CompressedTextureManager.js","./compressedImageParser.js","./extensionChooser.js","./extensionFixer.js",2,"CompressedImage","src","type","width","height","levels","internalFormat","complete","isCompressedImage","dispose","generateWebGLTexture","gl","preserveSource","offset","levelSize","textureLevelSize","dxtLevel","Uint8Array","buffer","ta","byteOffset","compressedTexImage2D","TEXTURE_2D","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_NEAREST","loadDDS","arrayBuffer","header","Int32Array","DDS_HEADER_LENGTH","DDS_HEADER_MAGIC","DDS_MAGIC","DDS_HEADER_PF_FLAGS","DDPF_FOURCC","fourCC","DDS_HEADER_PF_FOURCC","FOURCC_DXT1","COMPRESSED_RGB_S3TC_DXT1_EXT","FOURCC_DXT3","COMPRESSED_RGBA_S3TC_DXT3_EXT","FOURCC_DXT5","COMPRESSED_RGBA_S3TC_DXT5_EXT","FOURCC_ATC","COMPRESSED_RGB_ATC_WEBGL","FOURCC_ATCA","COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL","FOURCC_ATCI","COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL","int32ToFourCC","DDS_HEADER_FLAGS","DDSD_MIPMAPCOUNT","Math","max","DDS_HEADER_MIPMAPCOUNT","DDS_HEADER_WIDTH","DDS_HEADER_HEIGHT","dataOffset","DDS_HEADER_SIZE","dxtData","loadPVR","PVR_HEADER_LENGTH","PVR_HEADER_MAGIC","PVR_MAGIC","format","PVR_HEADER_FORMAT","PVR_FORMAT_2BPP_RGB","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","PVR_FORMAT_2BPP_RGBA","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","PVR_FORMAT_4BPP_RGB","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","PVR_FORMAT_4BPP_RGBA","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","PVR_FORMAT_ETC1","COMPRESSED_RGB_ETC1_WEBGL","PVR_FORMAT_DXT1","PVR_FORMAT_DXT3","PVR_FORMAT_DXT5","PVR_HEADER_WIDTH","PVR_HEADER_HEIGHT","PVR_HEADER_MIPMAPCOUNT","PVR_HEADER_METADATA","pvrtcData","fourCCToInt32","value","charCodeAt","String","fromCharCode","floor","loadFromArrayBuffer","entete",3,"WebGLManager","core","prototype","getExtension","name","vendorPrefixes","Object","create","constructor","ShaderManager","registerPlugin","updateTexture","texture","removeSource","source","_glTextures","id","createTexture","on","destroyTexture","bindTexture","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","premultipliedAlpha","updateAllCompressedTextures","resources","key","resource","updateAllTextures","isImage","./CompressedImage",4,"compressedTextureParser","supportedExtensions","next","xhr","xhrType","Resource","XHR_RESPONSE_TYPE","BUFFER","url","indexOf","baseTexture","BaseTexture","utils","getResolutionOfUrl","imageUrl","Texture","BaseTextureCache","TextureCache",5,"options","choice","_defaultUrlChoice","k","lastIndexOf","_baseUrl","substring","baseUrl","j","se",6,"textureExtensionFixer","_defaultUrl"],"mappings":"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","file":"pixi-compressed-textures.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (global){\nvar compressedTextures = {\r\n    CompressedTextureManager: require('./CompressedTextureManager.js'),\r\n    compressedImageParser: require('./compressedImageParser.js'),\r\n    extensionChooser: require('./extensionChooser.js'),\r\n    extensionFixer: require('./extensionFixer.js'),\r\n    detectExtensions: function(renderer) {\r\n        if (renderer instanceof PIXI.WebGLRenderer) {\r\n            var data = renderer.plugins['compressedTextureManager'].getSupportedExtensions();\r\n            if (data.dxt) extensions.push('.dxt');\r\n            if (data.pvrtc) extensions.push('.pvr');\r\n            if (data.atc) extensions.push('.atc');\r\n        } else if (renderer instanceof PIXI.CanvasRenderer) {\r\n            //nothing special for canvas\r\n        }\r\n        //retina!\r\n        if (renderer.resolution == 2 ) {\r\n            var ext = extensions.slice(0);\r\n            while (ext.length>0) {\r\n                extensions.push(\"@2x\"+ext.pop());\r\n            }\r\n            extensions.push(\"@2x.png\");\r\n            extensions.push(\"@2x.jpg\");\r\n        }\r\n    }\r\n};\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(compressedTextures.compressedImageParser);\r\nPIXI.loaders.Loader.addPixiMiddleware(compressedTextures.extensionFixer);\r\nPIXI.loader.use(compressedTextures.compressedImageParser());\r\nPIXI.loader.use(compressedTextures.extensionFixer());\r\n\r\nmodule.exports = global.PIXI.compressedTextures = compressedTextures;\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tcHJlc3NlZFRleHR1cmVzID0ge1xyXG4gICAgQ29tcHJlc3NlZFRleHR1cmVNYW5hZ2VyOiByZXF1aXJlKCcuL0NvbXByZXNzZWRUZXh0dXJlTWFuYWdlci5qcycpLFxyXG4gICAgY29tcHJlc3NlZEltYWdlUGFyc2VyOiByZXF1aXJlKCcuL2NvbXByZXNzZWRJbWFnZVBhcnNlci5qcycpLFxyXG4gICAgZXh0ZW5zaW9uQ2hvb3NlcjogcmVxdWlyZSgnLi9leHRlbnNpb25DaG9vc2VyLmpzJyksXHJcbiAgICBleHRlbnNpb25GaXhlcjogcmVxdWlyZSgnLi9leHRlbnNpb25GaXhlci5qcycpLFxyXG4gICAgZGV0ZWN0RXh0ZW5zaW9uczogZnVuY3Rpb24ocmVuZGVyZXIpIHtcclxuICAgICAgICBpZiAocmVuZGVyZXIgaW5zdGFuY2VvZiBQSVhJLldlYkdMUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSByZW5kZXJlci5wbHVnaW5zWydjb21wcmVzc2VkVGV4dHVyZU1hbmFnZXInXS5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLmR4dCkgZXh0ZW5zaW9ucy5wdXNoKCcuZHh0Jyk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnB2cnRjKSBleHRlbnNpb25zLnB1c2goJy5wdnInKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEuYXRjKSBleHRlbnNpb25zLnB1c2goJy5hdGMnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyIGluc3RhbmNlb2YgUElYSS5DYW52YXNSZW5kZXJlcikge1xyXG4gICAgICAgICAgICAvL25vdGhpbmcgc3BlY2lhbCBmb3IgY2FudmFzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vcmV0aW5hIVxyXG4gICAgICAgIGlmIChyZW5kZXJlci5yZXNvbHV0aW9uID09IDIgKSB7XHJcbiAgICAgICAgICAgIHZhciBleHQgPSBleHRlbnNpb25zLnNsaWNlKDApO1xyXG4gICAgICAgICAgICB3aGlsZSAoZXh0Lmxlbmd0aD4wKSB7XHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zLnB1c2goXCJAMnhcIitleHQucG9wKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChcIkAyeC5wbmdcIik7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChcIkAyeC5qcGdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuUElYSS5sb2FkZXJzLkxvYWRlci5hZGRQaXhpTWlkZGxld2FyZShjb21wcmVzc2VkVGV4dHVyZXMuY29tcHJlc3NlZEltYWdlUGFyc2VyKTtcclxuUElYSS5sb2FkZXJzLkxvYWRlci5hZGRQaXhpTWlkZGxld2FyZShjb21wcmVzc2VkVGV4dHVyZXMuZXh0ZW5zaW9uRml4ZXIpO1xyXG5QSVhJLmxvYWRlci51c2UoY29tcHJlc3NlZFRleHR1cmVzLmNvbXByZXNzZWRJbWFnZVBhcnNlcigpKTtcclxuUElYSS5sb2FkZXIudXNlKGNvbXByZXNzZWRUZXh0dXJlcy5leHRlbnNpb25GaXhlcigpKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLlBJWEkuY29tcHJlc3NlZFRleHR1cmVzID0gY29tcHJlc3NlZFRleHR1cmVzO1xyXG4iXX0=","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\nvar compressedTextures = {\r\n    CompressedTextureManager: require('./CompressedTextureManager.js'),\r\n    compressedImageParser: require('./compressedImageParser.js'),\r\n    extensionChooser: require('./extensionChooser.js'),\r\n    extensionFixer: require('./extensionFixer.js'),\r\n    detectExtensions: function(renderer) {\r\n        if (renderer instanceof PIXI.WebGLRenderer) {\r\n            var data = renderer.plugins['compressedTextureManager'].getSupportedExtensions();\r\n            if (data.dxt) extensions.push('.dxt');\r\n            if (data.pvrtc) extensions.push('.pvr');\r\n            if (data.atc) extensions.push('.atc');\r\n        } else if (renderer instanceof PIXI.CanvasRenderer) {\r\n            //nothing special for canvas\r\n        }\r\n        //retina!\r\n        if (renderer.resolution == 2 ) {\r\n            var ext = extensions.slice(0);\r\n            while (ext.length>0) {\r\n                extensions.push(\"@2x\"+ext.pop());\r\n            }\r\n            extensions.push(\"@2x.png\");\r\n            extensions.push(\"@2x.jpg\");\r\n        }\r\n    }\r\n};\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(compressedTextures.compressedImageParser);\r\nPIXI.loaders.Loader.addPixiMiddleware(compressedTextures.extensionFixer);\r\nPIXI.loader.use(compressedTextures.compressedImageParser());\r\nPIXI.loader.use(compressedTextures.extensionFixer());\r\n\r\nmodule.exports = global.PIXI.compressedTextures = compressedTextures;\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./CompressedTextureManager.js\":3,\"./compressedImageParser.js\":4,\"./extensionChooser.js\":5,\"./extensionFixer.js\":6}],2:[function(require,module,exports){\nfunction CompressedImage (src, data, type, width, height, levels, internalFormat) {\r\n    this.src = src;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.data = data;\r\n    this.type = type;\r\n    this.levels = levels;\r\n    this.internalFormat = internalFormat;\r\n    this.complete = true;\r\n    this.isCompressedImage = true;\r\n\r\n    this.dispose = function(){\r\n        this.data = null;\r\n    };\r\n\r\n    this.generateWebGLTexture = function(gl, preserveSource){\r\n        if(this.data == null)\r\n        {\r\n            throw \"Trying to create a second (or more) webgl texture from the same CompressedImage : \"+this.src;\r\n            return;\r\n        }\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var offset = 0;\r\n        // Loop through each mip level of compressed texture data provided and upload it to the given texture.\r\n        for (var i = 0; i < this.levels; ++i)\r\n        {\r\n            // Determine how big this level of compressed texture data is in bytes.\r\n            var levelSize = textureLevelSize(this.internalFormat, width, height);\r\n            // Get a view of the bytes for this level of DXT data.\r\n            var dxtLevel = new Uint8Array(this.data.buffer, this.ta.byteOffset + offset, levelSize);\r\n            // Upload!\r\n            gl.compressedTexImage2D(gl.TEXTURE_2D, i, this.internalFormat, width, height, 0, dxtLevel);\r\n            // The next mip level will be half the height and width of this one.\r\n            width = width >> 1;\r\n            if(width<1)\r\n                width = 1;\r\n            height = height >> 1;\r\n            if(height<1)\r\n                height = 1;\r\n            // Advance the offset into the compressed texture data past the current mip level's data.\r\n            offset += levelSize;\r\n        }\r\n\r\n        // We can't use gl.generateMipmaps with compressed textures, so only use\r\n        // mipmapped filtering if the compressed texture data contained mip levels.\r\n        if (levels > 1)\r\n        {\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\r\n        }\r\n        else\r\n        {\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        }\r\n\r\n        // Cleaning the data to save memory. NOTE : BECAUSE OF THIS WE CANNOT CREATE TWO GL TEXTURE FROM THE SAME COMPRESSED IMAGE !\r\n        if(!preserveSource)\r\n            this.data = null;\r\n    };\r\n};\r\n\r\nmodule.exports = CompressedImage;\r\n/**\r\n * Charge une image compressée depuis un array buffer\r\n * @param arrayBuffer : le buffer à partir duquel charger l'image\r\n * @return la CompressedImage chargée\r\n */\r\nCompressedImage.loadFromArrayBuffer = function(arrayBuffer, src){\r\n    var entete = new Uint8Array(arrayBuffer, 0, 3);\r\n\r\n    if(entete[0]==\"DDS\".charCodeAt(0) && entete[1]==\"DDS\".charCodeAt(1) && entete[2]==\"DDS\".charCodeAt(2))\r\n        return loadDDS(arrayBuffer, src);\r\n    else if(entete[0]==\"PVR\".charCodeAt(0) && entete[1]==\"PVR\".charCodeAt(1) && entete[2]==\"PVR\".charCodeAt(2))\r\n        return loadPVR(arrayBuffer, src);\r\n    else\r\n        throw \"Compressed texture format is not recognized: \"+src;\r\n};\r\n\r\n/**\r\n * Charge une image compressГ©e au format DDS depuis un array buffer\r\n * @param arrayBuffer : le buffer Г  partir duquel charger l'image\r\n * @return la CompressedImage chargГ©e\r\n */\r\nfunction loadDDS(arrayBuffer, src){\r\n    // Get a view of the arrayBuffer that represents the DDS header.\r\n    var header = new Int32Array(arrayBuffer, 0, DDS_HEADER_LENGTH);\r\n\r\n    // Do some sanity checks to make sure this is a valid DDS file.\r\n    if(header[DDS_HEADER_MAGIC] != DDS_MAGIC)\r\n        throw \"Invalid magic number in DDS header\";\r\n\r\n    if(!header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC)\r\n        throw \"Unsupported format, must contain a FourCC code\";\r\n\r\n    // Determine what type of compressed data the file contains.\r\n    var fourCC = header[DDS_HEADER_PF_FOURCC];\r\n    var internalFormat;\r\n    switch(fourCC) {\r\n        case FOURCC_DXT1:\r\n            internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n            break;\r\n        case FOURCC_DXT3:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n            break;\r\n        case FOURCC_DXT5:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n            break;\r\n        case FOURCC_ATC:\r\n            internalFormat = COMPRESSED_RGB_ATC_WEBGL;\r\n            break;\r\n        case FOURCC_ATCA:\r\n            internalFormat = COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL;\r\n            break;\r\n        case FOURCC_ATCI:\r\n            internalFormat = COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;\r\n            break;\r\n        default:\r\n            throw \"Unsupported FourCC code: \" + int32ToFourCC(fourCC);\r\n    }\r\n\r\n    // Determine how many mipmap levels the file contains.\r\n    var levels = 1;\r\n    if(header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {\r\n        levels = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);\r\n    }\r\n\r\n    // Gather other basic metrics and a view of the raw the DXT data.\r\n    var width = header[DDS_HEADER_WIDTH];\r\n    var height = header[DDS_HEADER_HEIGHT];\r\n    var dataOffset = header[DDS_HEADER_SIZE] + 4;\r\n    var dxtData = new Uint8Array(arrayBuffer, dataOffset);\r\n\r\n    return new CompressedImage(src, dxtData, 'DDS', width, height, levels, internalFormat);\r\n};\r\n\r\n/**\r\n * Charge une image compressГ©e au format PVR depuis un array buffer\r\n * @param arrayBuffer : le buffer Г  partir duquel charger l'image\r\n * @return la CompressedImage chargГ©e\r\n */\r\nfunction loadPVR(arrayBuffer, src){\r\n    // Get a view of the arrayBuffer that represents the DDS header.\r\n    var header = new Int32Array(arrayBuffer, 0, PVR_HEADER_LENGTH);\r\n\r\n    // Do some sanity checks to make sure this is a valid DDS file.\r\n    if(header[PVR_HEADER_MAGIC] != PVR_MAGIC)\r\n        throw \"Invalid magic number in PVR header\";\r\n\r\n    // Determine what type of compressed data the file contains.\r\n    var format = header[PVR_HEADER_FORMAT];\r\n    var internalFormat;\r\n    switch(format) {\r\n        case PVR_FORMAT_2BPP_RGB:\r\n            internalFormat = COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_2BPP_RGBA:\r\n            internalFormat = COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_4BPP_RGB:\r\n            internalFormat = COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_4BPP_RGBA:\r\n            internalFormat = COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_ETC1:\r\n            internalFormat = COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case PVR_FORMAT_DXT1:\r\n            internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n            break;\r\n        case PVR_FORMAT_DXT3:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n            break;\r\n        case PVR_FORMAT_DXT5:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n            break;\r\n        default:\r\n            throw \"Unsupported PVR format: \" + format;\r\n    }\r\n\r\n    // Gather other basic metrics and a view of the raw the DXT data.\r\n    var width = header[PVR_HEADER_WIDTH];\r\n    var height = header[PVR_HEADER_HEIGHT];\r\n    var levels = header[PVR_HEADER_MIPMAPCOUNT];\r\n    var dataOffset = header[PVR_HEADER_METADATA] + 52;\r\n    var pvrtcData = new Uint8Array(arrayBuffer, dataOffset);\r\n\r\n    return new CompressedImage(src, pvrtcData, 'PVR', width, height, levels, internalFormat);\r\n};\r\n\r\n\r\n//============================//\r\n// DXT constants and utilites //\r\n//============================//\r\n\r\n// Utility functions\r\n// Builds a numeric code for a given fourCC string\r\nfunction fourCCToInt32(value) {\r\n    return value.charCodeAt(0) +\r\n        (value.charCodeAt(1) << 8) +\r\n        (value.charCodeAt(2) << 16) +\r\n        (value.charCodeAt(3) << 24);\r\n}\r\n\r\n// Turns a fourCC numeric code into a string\r\nfunction int32ToFourCC(value) {\r\n    return String.fromCharCode(\r\n        value & 0xff,\r\n        (value >> 8) & 0xff,\r\n        (value >> 16) & 0xff,\r\n        (value >> 24) & 0xff\r\n    );\r\n}\r\n\r\n// Calcualates the size of a compressed texture level in bytes\r\nfunction textureLevelSize(format, width, height) {\r\n    switch (format) {\r\n        case COMPRESSED_RGB_S3TC_DXT1_EXT:\r\n        case COMPRESSED_RGB_ATC_WEBGL:\r\n        case COMPRESSED_RGB_ETC1_WEBGL:\r\n            return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\r\n\r\n        case COMPRESSED_RGBA_S3TC_DXT3_EXT:\r\n        case COMPRESSED_RGBA_S3TC_DXT5_EXT:\r\n        case COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:\r\n        case COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:\r\n            return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\r\n\r\n        case COMPRESSED_RGB_PVRTC_4BPPV1_IMG:\r\n        case COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:\r\n            return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);\r\n\r\n        case COMPRESSED_RGB_PVRTC_2BPPV1_IMG:\r\n        case COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:\r\n            return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);\r\n\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\n// DXT formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\r\nvar COMPRESSED_RGB_S3TC_DXT1_EXT  = 0x83F0;\r\nvar COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\r\nvar COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\r\nvar COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\r\n\r\n// ATC formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_atc/\r\nvar COMPRESSED_RGB_ATC_WEBGL                     = 0x8C92;\r\nvar COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL     = 0x8C93;\r\nvar COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\r\n\r\n// DXT values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nvar DDS_MAGIC = 0x20534444;\r\nvar DDSD_MIPMAPCOUNT = 0x20000;\r\nvar DDPF_FOURCC = 0x4;\r\n\r\nvar DDS_HEADER_LENGTH = 31; // The header length in 32 bit ints.\r\n\r\n// Offsets into the header array.\r\nvar DDS_HEADER_MAGIC = 0;\r\n\r\nvar DDS_HEADER_SIZE = 1;\r\nvar DDS_HEADER_FLAGS = 2;\r\nvar DDS_HEADER_HEIGHT = 3;\r\nvar DDS_HEADER_WIDTH = 4;\r\n\r\nvar DDS_HEADER_MIPMAPCOUNT = 7;\r\n\r\nvar DDS_HEADER_PF_FLAGS = 20;\r\nvar DDS_HEADER_PF_FOURCC = 21;\r\n\r\n// FourCC format identifiers.\r\nvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\r\nvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\r\nvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\r\n\r\nvar FOURCC_ATC = fourCCToInt32(\"ATC \");\r\nvar FOURCC_ATCA = fourCCToInt32(\"ATCA\");\r\nvar FOURCC_ATCI = fourCCToInt32(\"ATCI\");\r\n\r\n//===============//\r\n// PVR constants //\r\n//===============//\r\n\r\n// PVR formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\r\nvar COMPRESSED_RGB_PVRTC_4BPPV1_IMG  = 0x8C00;\r\nvar COMPRESSED_RGB_PVRTC_2BPPV1_IMG  = 0x8C01;\r\nvar COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\r\nvar COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\r\n\r\n// ETC1 format, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/\r\nvar COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;\r\n\r\nvar PVR_FORMAT_2BPP_RGB  = 0;\r\nvar PVR_FORMAT_2BPP_RGBA = 1;\r\nvar PVR_FORMAT_4BPP_RGB  = 2;\r\nvar PVR_FORMAT_4BPP_RGBA = 3;\r\nvar PVR_FORMAT_ETC1      = 6;\r\nvar PVR_FORMAT_DXT1      = 7;\r\nvar PVR_FORMAT_DXT3      = 9;\r\nvar PVR_FORMAT_DXT5      = 5;\r\n\r\nvar PVR_HEADER_LENGTH = 13; // The header length in 32 bit ints.\r\nvar PVR_MAGIC = 0x03525650; //0x50565203;\r\n\r\n// Offsets into the header array.\r\nvar PVR_HEADER_MAGIC = 0;\r\nvar PVR_HEADER_FORMAT = 2;\r\nvar PVR_HEADER_HEIGHT = 6;\r\nvar PVR_HEADER_WIDTH = 7;\r\nvar PVR_HEADER_MIPMAPCOUNT = 11;\r\nvar PVR_HEADER_METADATA = 12;\r\n\n},{}],3:[function(require,module,exports){\n/**\r\n * Created by Liza on 12.12.2015.\r\n */\r\n\r\nvar core = PIXI,\r\n    CompressedImage = require('./CompressedImage'),\r\n    WebGLManager = core.WebGLManager;\r\n/**\r\n * @class\r\n * @memberof PIXI.compressedTextures\r\n * @extends PIXI.WebGlManager\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\r\n */\r\nfunction CompressedTextureManager(renderer)\r\n{\r\n    WebGLManager.call(this, renderer);\r\n}\r\n\r\nCompressedTextureManager.prototype.getSupportedExtensions = function() {\r\n    function getExtension(gl, name) {\r\n        var vendorPrefixes = [\"\", \"WEBKIT_\", \"MOZ_\"];\r\n        var ext = null;\r\n        for (var i in vendorPrefixes) {\r\n            ext = gl.getExtension(vendorPrefixes[i] + name);\r\n            if (ext) { break; }\r\n        }\r\n        return ext;\r\n    }\r\n\r\n    return {\r\n        dxt : getExtension(gl, \"WEBGL_compressed_texture_s3tc\"),\r\n        pvrtc : getExtension(gl, \"WEBGL_compressed_texture_pvrtc\"),\r\n        atc : getExtension(gl, \"WEBGL_compressed_texture_atc\")\r\n    }\r\n};\r\n\r\nCompressedTextureManager.prototype = Object.create(WebGLManager.prototype);\r\nCompressedTextureManager.prototype.constructor = CompressedTextureManager;\r\nmodule.exports = CompressedTextureManager;\r\n\r\ncore.ShaderManager.registerPlugin('compressedTextureManager', CompressedTextureManager);\r\n\r\nCompressedTextureManager.prototype.updateTexture = function(texture, removeSource) {\r\n    var renderer = this.renderer;\r\n    var gl = this.renderer.gl;\r\n    var source = texture.source;\r\n    if (!(source instanceof CompressedImage)) {\r\n        throw \"Not a compressed image\";\r\n    }\r\n    if (!texture._glTextures[gl.id])\r\n    {\r\n        texture._glTextures[gl.id] = gl.createTexture();\r\n        texture.on('dispose', renderer.destroyTexture, renderer);\r\n    }\r\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);\r\n    source.generateWebGLTexture(gl, !removeSource);\r\n};\r\n\r\nCompressedTextureManager.prototype.updateAllCompressedTextures = function(resources, removeSource) {\r\n    for (var key in resources) {\r\n        var resource = resources[key];\r\n        if (resource.isCompressedImage) {\r\n            this.updateTexture(resource.texture, removeSource);\r\n        }\r\n    }\r\n};\r\n\r\nCompressedTextureManager.prototype.updateAllTextures = function(resources, removeSource) {\r\n    for (var key in resources) {\r\n        var resource = resources[key];\r\n        if (resource.isCompressedImage) {\r\n            this.updateTexture(resource.texture);\r\n        } else if (resource.isImage) {\r\n            renderer.updateTexture(resource.texture);\r\n        }\r\n    }\r\n};\n},{\"./CompressedImage\":2}],4:[function(require,module,exports){\nvar core = PIXI,\n    utils = core.utils,\n    CompressedImage = require('./CompressedImage');\n\nfunction compressedTextureParser(supportedExtensions) {\n    supportedExtensions = supportedExtensions || [];\n\n    return function (resource, next) {\n        resource.isCompressedImage = false;\n        if(resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BUFFER){\n            if(resource.url.indexOf('.dds') != -1 || resource.url.indexOf('.pvr') != -1)\n            {\n                var baseTexture = new core.BaseTexture(resource.data, null, core.utils.getResolutionOfUrl(resource.url));\n                baseTexture.imageUrl = resource.url;\n\n                resource.texture = new PIXI.Texture(baseTexture);\n                resource.data = null;\n                resource.isCompressedImage = true;\n\n                utils.BaseTextureCache[baseTexture.imageUrl] = baseTexture;\n                utils.TextureCache[baseTexture.imageUrl] = resource.texture;\n            }\n        }\n        next();\n    }\n}\n\nmodule.exports = compressedTextureParser;\n\n},{\"./CompressedImage\":2}],5:[function(require,module,exports){\nfunction extensionChooser(supportedExtensions) {\n    supportedExtensions = supportedExtensions || [];\n\n    return function (resource, next) {\n        var ext = resource.options.choice;\n        if (ext) {\n            //let us choose extension!\n            var url = resource.url;\n            if (!resource._defaultUrlChoice) {\n                resource._defaultUrlChoice = url;\n                var k = url.lastIndexOf(\".\");\n                if (k>=0) {\n                    resource._baseUrl = url.substring(0, k);\n                } else {\n                    return next();\n                }\n            }\n            for (var i=ext.length-1;i>=0;i--) {\n                var url = baseUrl + ext[i];\n                for (var j=0;j<supportedExtensions.length;j++) {\n                    var se = supportedExtensions[j];\n                    if (url.length >= se.length  && url.substring(url.length-se.length) == se) {\n                        resource.url = url;\n                        return next();\n                    }\n                }\n            }\n        }\n        next();\n    }\n}\n\nmodule.exports = extensionChooser;\n\n},{}],6:[function(require,module,exports){\nvar core = PIXI,\r\n    utils = core.utils,\r\n    extensionFixer = require('./CompressedImage');\r\n\r\nfunction textureExtensionFixer(supportedExtensions) {\r\n    return function (resource, next) {\r\n        if (resource.texture && resource._defaultUrlChoice && resource._defaultUrl != resource.url) {\r\n            var texture = resource.texture;\r\n            var baseTexture = texture.baseTexture;\r\n            delete utils.BaseTextureCache[baseTexture.imageUrl];\r\n            delete utils.TextureCache[baseTexture.imageUrl];\r\n            baseTexture.imageUrl = resource._defaultUrlChoice;\r\n            core.utils.BaseTextureCache[baseTexture.imageUrl] = baseTexture;\r\n            core.utils.TextureCache[baseTexture.imageUrl] = texture;\r\n        }\r\n        next();\r\n    }\r\n}\r\n\r\nmodule.exports = textureExtensionFixer;\r\n\n},{\"./CompressedImage\":2}]},{},[1])\n\n","function CompressedImage (src, data, type, width, height, levels, internalFormat) {\r\n    this.src = src;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.data = data;\r\n    this.type = type;\r\n    this.levels = levels;\r\n    this.internalFormat = internalFormat;\r\n    this.complete = true;\r\n    this.isCompressedImage = true;\r\n\r\n    this.dispose = function(){\r\n        this.data = null;\r\n    };\r\n\r\n    this.generateWebGLTexture = function(gl, preserveSource){\r\n        if(this.data == null)\r\n        {\r\n            throw \"Trying to create a second (or more) webgl texture from the same CompressedImage : \"+this.src;\r\n            return;\r\n        }\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var offset = 0;\r\n        // Loop through each mip level of compressed texture data provided and upload it to the given texture.\r\n        for (var i = 0; i < this.levels; ++i)\r\n        {\r\n            // Determine how big this level of compressed texture data is in bytes.\r\n            var levelSize = textureLevelSize(this.internalFormat, width, height);\r\n            // Get a view of the bytes for this level of DXT data.\r\n            var dxtLevel = new Uint8Array(this.data.buffer, this.ta.byteOffset + offset, levelSize);\r\n            // Upload!\r\n            gl.compressedTexImage2D(gl.TEXTURE_2D, i, this.internalFormat, width, height, 0, dxtLevel);\r\n            // The next mip level will be half the height and width of this one.\r\n            width = width >> 1;\r\n            if(width<1)\r\n                width = 1;\r\n            height = height >> 1;\r\n            if(height<1)\r\n                height = 1;\r\n            // Advance the offset into the compressed texture data past the current mip level's data.\r\n            offset += levelSize;\r\n        }\r\n\r\n        // We can't use gl.generateMipmaps with compressed textures, so only use\r\n        // mipmapped filtering if the compressed texture data contained mip levels.\r\n        if (levels > 1)\r\n        {\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\r\n        }\r\n        else\r\n        {\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        }\r\n\r\n        // Cleaning the data to save memory. NOTE : BECAUSE OF THIS WE CANNOT CREATE TWO GL TEXTURE FROM THE SAME COMPRESSED IMAGE !\r\n        if(!preserveSource)\r\n            this.data = null;\r\n    };\r\n};\r\n\r\nmodule.exports = CompressedImage;\r\n/**\r\n * Charge une image compressée depuis un array buffer\r\n * @param arrayBuffer : le buffer à partir duquel charger l'image\r\n * @return la CompressedImage chargée\r\n */\r\nCompressedImage.loadFromArrayBuffer = function(arrayBuffer, src){\r\n    var entete = new Uint8Array(arrayBuffer, 0, 3);\r\n\r\n    if(entete[0]==\"DDS\".charCodeAt(0) && entete[1]==\"DDS\".charCodeAt(1) && entete[2]==\"DDS\".charCodeAt(2))\r\n        return loadDDS(arrayBuffer, src);\r\n    else if(entete[0]==\"PVR\".charCodeAt(0) && entete[1]==\"PVR\".charCodeAt(1) && entete[2]==\"PVR\".charCodeAt(2))\r\n        return loadPVR(arrayBuffer, src);\r\n    else\r\n        throw \"Compressed texture format is not recognized: \"+src;\r\n};\r\n\r\n/**\r\n * Charge une image compressГ©e au format DDS depuis un array buffer\r\n * @param arrayBuffer : le buffer Г  partir duquel charger l'image\r\n * @return la CompressedImage chargГ©e\r\n */\r\nfunction loadDDS(arrayBuffer, src){\r\n    // Get a view of the arrayBuffer that represents the DDS header.\r\n    var header = new Int32Array(arrayBuffer, 0, DDS_HEADER_LENGTH);\r\n\r\n    // Do some sanity checks to make sure this is a valid DDS file.\r\n    if(header[DDS_HEADER_MAGIC] != DDS_MAGIC)\r\n        throw \"Invalid magic number in DDS header\";\r\n\r\n    if(!header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC)\r\n        throw \"Unsupported format, must contain a FourCC code\";\r\n\r\n    // Determine what type of compressed data the file contains.\r\n    var fourCC = header[DDS_HEADER_PF_FOURCC];\r\n    var internalFormat;\r\n    switch(fourCC) {\r\n        case FOURCC_DXT1:\r\n            internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n            break;\r\n        case FOURCC_DXT3:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n            break;\r\n        case FOURCC_DXT5:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n            break;\r\n        case FOURCC_ATC:\r\n            internalFormat = COMPRESSED_RGB_ATC_WEBGL;\r\n            break;\r\n        case FOURCC_ATCA:\r\n            internalFormat = COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL;\r\n            break;\r\n        case FOURCC_ATCI:\r\n            internalFormat = COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;\r\n            break;\r\n        default:\r\n            throw \"Unsupported FourCC code: \" + int32ToFourCC(fourCC);\r\n    }\r\n\r\n    // Determine how many mipmap levels the file contains.\r\n    var levels = 1;\r\n    if(header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {\r\n        levels = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);\r\n    }\r\n\r\n    // Gather other basic metrics and a view of the raw the DXT data.\r\n    var width = header[DDS_HEADER_WIDTH];\r\n    var height = header[DDS_HEADER_HEIGHT];\r\n    var dataOffset = header[DDS_HEADER_SIZE] + 4;\r\n    var dxtData = new Uint8Array(arrayBuffer, dataOffset);\r\n\r\n    return new CompressedImage(src, dxtData, 'DDS', width, height, levels, internalFormat);\r\n};\r\n\r\n/**\r\n * Charge une image compressГ©e au format PVR depuis un array buffer\r\n * @param arrayBuffer : le buffer Г  partir duquel charger l'image\r\n * @return la CompressedImage chargГ©e\r\n */\r\nfunction loadPVR(arrayBuffer, src){\r\n    // Get a view of the arrayBuffer that represents the DDS header.\r\n    var header = new Int32Array(arrayBuffer, 0, PVR_HEADER_LENGTH);\r\n\r\n    // Do some sanity checks to make sure this is a valid DDS file.\r\n    if(header[PVR_HEADER_MAGIC] != PVR_MAGIC)\r\n        throw \"Invalid magic number in PVR header\";\r\n\r\n    // Determine what type of compressed data the file contains.\r\n    var format = header[PVR_HEADER_FORMAT];\r\n    var internalFormat;\r\n    switch(format) {\r\n        case PVR_FORMAT_2BPP_RGB:\r\n            internalFormat = COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_2BPP_RGBA:\r\n            internalFormat = COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_4BPP_RGB:\r\n            internalFormat = COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_4BPP_RGBA:\r\n            internalFormat = COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n            break;\r\n        case PVR_FORMAT_ETC1:\r\n            internalFormat = COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case PVR_FORMAT_DXT1:\r\n            internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n            break;\r\n        case PVR_FORMAT_DXT3:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n            break;\r\n        case PVR_FORMAT_DXT5:\r\n            internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n            break;\r\n        default:\r\n            throw \"Unsupported PVR format: \" + format;\r\n    }\r\n\r\n    // Gather other basic metrics and a view of the raw the DXT data.\r\n    var width = header[PVR_HEADER_WIDTH];\r\n    var height = header[PVR_HEADER_HEIGHT];\r\n    var levels = header[PVR_HEADER_MIPMAPCOUNT];\r\n    var dataOffset = header[PVR_HEADER_METADATA] + 52;\r\n    var pvrtcData = new Uint8Array(arrayBuffer, dataOffset);\r\n\r\n    return new CompressedImage(src, pvrtcData, 'PVR', width, height, levels, internalFormat);\r\n};\r\n\r\n\r\n//============================//\r\n// DXT constants and utilites //\r\n//============================//\r\n\r\n// Utility functions\r\n// Builds a numeric code for a given fourCC string\r\nfunction fourCCToInt32(value) {\r\n    return value.charCodeAt(0) +\r\n        (value.charCodeAt(1) << 8) +\r\n        (value.charCodeAt(2) << 16) +\r\n        (value.charCodeAt(3) << 24);\r\n}\r\n\r\n// Turns a fourCC numeric code into a string\r\nfunction int32ToFourCC(value) {\r\n    return String.fromCharCode(\r\n        value & 0xff,\r\n        (value >> 8) & 0xff,\r\n        (value >> 16) & 0xff,\r\n        (value >> 24) & 0xff\r\n    );\r\n}\r\n\r\n// Calcualates the size of a compressed texture level in bytes\r\nfunction textureLevelSize(format, width, height) {\r\n    switch (format) {\r\n        case COMPRESSED_RGB_S3TC_DXT1_EXT:\r\n        case COMPRESSED_RGB_ATC_WEBGL:\r\n        case COMPRESSED_RGB_ETC1_WEBGL:\r\n            return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\r\n\r\n        case COMPRESSED_RGBA_S3TC_DXT3_EXT:\r\n        case COMPRESSED_RGBA_S3TC_DXT5_EXT:\r\n        case COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:\r\n        case COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:\r\n            return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\r\n\r\n        case COMPRESSED_RGB_PVRTC_4BPPV1_IMG:\r\n        case COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:\r\n            return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);\r\n\r\n        case COMPRESSED_RGB_PVRTC_2BPPV1_IMG:\r\n        case COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:\r\n            return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);\r\n\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\n// DXT formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\r\nvar COMPRESSED_RGB_S3TC_DXT1_EXT  = 0x83F0;\r\nvar COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\r\nvar COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\r\nvar COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\r\n\r\n// ATC formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_atc/\r\nvar COMPRESSED_RGB_ATC_WEBGL                     = 0x8C92;\r\nvar COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL     = 0x8C93;\r\nvar COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\r\n\r\n// DXT values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nvar DDS_MAGIC = 0x20534444;\r\nvar DDSD_MIPMAPCOUNT = 0x20000;\r\nvar DDPF_FOURCC = 0x4;\r\n\r\nvar DDS_HEADER_LENGTH = 31; // The header length in 32 bit ints.\r\n\r\n// Offsets into the header array.\r\nvar DDS_HEADER_MAGIC = 0;\r\n\r\nvar DDS_HEADER_SIZE = 1;\r\nvar DDS_HEADER_FLAGS = 2;\r\nvar DDS_HEADER_HEIGHT = 3;\r\nvar DDS_HEADER_WIDTH = 4;\r\n\r\nvar DDS_HEADER_MIPMAPCOUNT = 7;\r\n\r\nvar DDS_HEADER_PF_FLAGS = 20;\r\nvar DDS_HEADER_PF_FOURCC = 21;\r\n\r\n// FourCC format identifiers.\r\nvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\r\nvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\r\nvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\r\n\r\nvar FOURCC_ATC = fourCCToInt32(\"ATC \");\r\nvar FOURCC_ATCA = fourCCToInt32(\"ATCA\");\r\nvar FOURCC_ATCI = fourCCToInt32(\"ATCI\");\r\n\r\n//===============//\r\n// PVR constants //\r\n//===============//\r\n\r\n// PVR formats, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\r\nvar COMPRESSED_RGB_PVRTC_4BPPV1_IMG  = 0x8C00;\r\nvar COMPRESSED_RGB_PVRTC_2BPPV1_IMG  = 0x8C01;\r\nvar COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\r\nvar COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\r\n\r\n// ETC1 format, from:\r\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/\r\nvar COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;\r\n\r\nvar PVR_FORMAT_2BPP_RGB  = 0;\r\nvar PVR_FORMAT_2BPP_RGBA = 1;\r\nvar PVR_FORMAT_4BPP_RGB  = 2;\r\nvar PVR_FORMAT_4BPP_RGBA = 3;\r\nvar PVR_FORMAT_ETC1      = 6;\r\nvar PVR_FORMAT_DXT1      = 7;\r\nvar PVR_FORMAT_DXT3      = 9;\r\nvar PVR_FORMAT_DXT5      = 5;\r\n\r\nvar PVR_HEADER_LENGTH = 13; // The header length in 32 bit ints.\r\nvar PVR_MAGIC = 0x03525650; //0x50565203;\r\n\r\n// Offsets into the header array.\r\nvar PVR_HEADER_MAGIC = 0;\r\nvar PVR_HEADER_FORMAT = 2;\r\nvar PVR_HEADER_HEIGHT = 6;\r\nvar PVR_HEADER_WIDTH = 7;\r\nvar PVR_HEADER_MIPMAPCOUNT = 11;\r\nvar PVR_HEADER_METADATA = 12;\r\n","/**\r\n * Created by Liza on 12.12.2015.\r\n */\r\n\r\nvar core = PIXI,\r\n    CompressedImage = require('./CompressedImage'),\r\n    WebGLManager = core.WebGLManager;\r\n/**\r\n * @class\r\n * @memberof PIXI.compressedTextures\r\n * @extends PIXI.WebGlManager\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\r\n */\r\nfunction CompressedTextureManager(renderer)\r\n{\r\n    WebGLManager.call(this, renderer);\r\n}\r\n\r\nCompressedTextureManager.prototype.getSupportedExtensions = function() {\r\n    function getExtension(gl, name) {\r\n        var vendorPrefixes = [\"\", \"WEBKIT_\", \"MOZ_\"];\r\n        var ext = null;\r\n        for (var i in vendorPrefixes) {\r\n            ext = gl.getExtension(vendorPrefixes[i] + name);\r\n            if (ext) { break; }\r\n        }\r\n        return ext;\r\n    }\r\n\r\n    return {\r\n        dxt : getExtension(gl, \"WEBGL_compressed_texture_s3tc\"),\r\n        pvrtc : getExtension(gl, \"WEBGL_compressed_texture_pvrtc\"),\r\n        atc : getExtension(gl, \"WEBGL_compressed_texture_atc\")\r\n    }\r\n};\r\n\r\nCompressedTextureManager.prototype = Object.create(WebGLManager.prototype);\r\nCompressedTextureManager.prototype.constructor = CompressedTextureManager;\r\nmodule.exports = CompressedTextureManager;\r\n\r\ncore.ShaderManager.registerPlugin('compressedTextureManager', CompressedTextureManager);\r\n\r\nCompressedTextureManager.prototype.updateTexture = function(texture, removeSource) {\r\n    var renderer = this.renderer;\r\n    var gl = this.renderer.gl;\r\n    var source = texture.source;\r\n    if (!(source instanceof CompressedImage)) {\r\n        throw \"Not a compressed image\";\r\n    }\r\n    if (!texture._glTextures[gl.id])\r\n    {\r\n        texture._glTextures[gl.id] = gl.createTexture();\r\n        texture.on('dispose', renderer.destroyTexture, renderer);\r\n    }\r\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);\r\n    source.generateWebGLTexture(gl, !removeSource);\r\n};\r\n\r\nCompressedTextureManager.prototype.updateAllCompressedTextures = function(resources, removeSource) {\r\n    for (var key in resources) {\r\n        var resource = resources[key];\r\n        if (resource.isCompressedImage) {\r\n            this.updateTexture(resource.texture, removeSource);\r\n        }\r\n    }\r\n};\r\n\r\nCompressedTextureManager.prototype.updateAllTextures = function(resources, removeSource) {\r\n    for (var key in resources) {\r\n        var resource = resources[key];\r\n        if (resource.isCompressedImage) {\r\n            this.updateTexture(resource.texture);\r\n        } else if (resource.isImage) {\r\n            renderer.updateTexture(resource.texture);\r\n        }\r\n    }\r\n};","var core = PIXI,\n    utils = core.utils,\n    CompressedImage = require('./CompressedImage');\n\nfunction compressedTextureParser(supportedExtensions) {\n    supportedExtensions = supportedExtensions || [];\n\n    return function (resource, next) {\n        resource.isCompressedImage = false;\n        if(resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BUFFER){\n            if(resource.url.indexOf('.dds') != -1 || resource.url.indexOf('.pvr') != -1)\n            {\n                var baseTexture = new core.BaseTexture(resource.data, null, core.utils.getResolutionOfUrl(resource.url));\n                baseTexture.imageUrl = resource.url;\n\n                resource.texture = new PIXI.Texture(baseTexture);\n                resource.data = null;\n                resource.isCompressedImage = true;\n\n                utils.BaseTextureCache[baseTexture.imageUrl] = baseTexture;\n                utils.TextureCache[baseTexture.imageUrl] = resource.texture;\n            }\n        }\n        next();\n    }\n}\n\nmodule.exports = compressedTextureParser;\n","function extensionChooser(supportedExtensions) {\n    supportedExtensions = supportedExtensions || [];\n\n    return function (resource, next) {\n        var ext = resource.options.choice;\n        if (ext) {\n            //let us choose extension!\n            var url = resource.url;\n            if (!resource._defaultUrlChoice) {\n                resource._defaultUrlChoice = url;\n                var k = url.lastIndexOf(\".\");\n                if (k>=0) {\n                    resource._baseUrl = url.substring(0, k);\n                } else {\n                    return next();\n                }\n            }\n            for (var i=ext.length-1;i>=0;i--) {\n                var url = baseUrl + ext[i];\n                for (var j=0;j<supportedExtensions.length;j++) {\n                    var se = supportedExtensions[j];\n                    if (url.length >= se.length  && url.substring(url.length-se.length) == se) {\n                        resource.url = url;\n                        return next();\n                    }\n                }\n            }\n        }\n        next();\n    }\n}\n\nmodule.exports = extensionChooser;\n","var core = PIXI,\r\n    utils = core.utils,\r\n    extensionFixer = require('./CompressedImage');\r\n\r\nfunction textureExtensionFixer(supportedExtensions) {\r\n    return function (resource, next) {\r\n        if (resource.texture && resource._defaultUrlChoice && resource._defaultUrl != resource.url) {\r\n            var texture = resource.texture;\r\n            var baseTexture = texture.baseTexture;\r\n            delete utils.BaseTextureCache[baseTexture.imageUrl];\r\n            delete utils.TextureCache[baseTexture.imageUrl];\r\n            baseTexture.imageUrl = resource._defaultUrlChoice;\r\n            core.utils.BaseTextureCache[baseTexture.imageUrl] = baseTexture;\r\n            core.utils.TextureCache[baseTexture.imageUrl] = texture;\r\n        }\r\n        next();\r\n    }\r\n}\r\n\r\nmodule.exports = textureExtensionFixer;\r\n"],"sourceRoot":"./"}